<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Windows Logo Evolution</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      font-family: Arial, sans-serif;
    }
    canvas {
      border: 1px solid black;
    }
    button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 16px;
    }
    #controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 20px;
    }
    label {
      margin: 5px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label>
      最初の区切り数 (3-6):
      <input type="number" id="initial-segments" min="3" max="6" value="4">
    </label>
    <label>
      変化の頻度 (1-10):
      <input type="number" id="change-frequency" min="1" max="10" value="5">
    </label>
    <button id="generate">生成</button>
  </div>
  <canvas id="canvas" width="1600" height="1200"></canvas>
  <button id="download">ダウンロード</button>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const generateButton = document.getElementById('generate');
    const downloadButton = document.getElementById('download');
    const initialSegmentsInput = document.getElementById('initial-segments');
    const changeFrequencyInput = document.getElementById('change-frequency');

    const colors = ['#FFFFFF', '#AAFFFF', '#44FFFF', '#00FFFF', '#00AAFF', '#0044FF', '#0000FF', '#00AAAA'];
    const shapeTypes = [
      '4区切り', '8区切り', 'くりぬき', '枠のみ四角', '2角丸四角', '2角丸中図形',
      'グラデーション', 'なめらか四角', 'ひし形', '円形', '回転区切り', 'パソコン回転',
      '同心円', '三角形連なり', '六角形', '星形', 'ギザギザ', '螺旋', '対角線模様'
    ];

    function getRandomElement(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function drawLogo(ctx, x, y, size, year, color, type) {
      ctx.fillStyle = color;
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;

      switch (type) {
        case '4区切り':
          for (let i = 0; i < 2; i++) {
            for (let j = 0; j < 2; j++) {
              ctx.fillRect(x + i * size / 2, y + j * size / 2, size / 2, size / 2);
            }
          }
          ctx.clearRect(x + size / 4, y + size / 4, size / 2, size / 2);
          break;
        case '8区切り':
          for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
              ctx.fillRect(x + i * size / 3, y + j * size / 3, size / 3, size / 3);
            }
          }
          ctx.clearRect(x + size / 6, y + size / 6, 2 * size / 3, 2 * size / 3);
          break;
        case 'くりぬき':
          ctx.fillRect(x, y, size, size);
          ctx.clearRect(x + size / 4, y + size / 4, size / 2, size / 2);
          break;
        case '枠のみ四角':
          ctx.strokeRect(x, y, size, size);
          break;
        case '2角丸四角':
          ctx.beginPath();
          ctx.moveTo(x, y + size / 2);
          ctx.arcTo(x, y, x + size / 2, y, size / 4);
          ctx.lineTo(x + size, y);
          ctx.arcTo(x + size, y, x + size, y + size / 2, size / 4);
          ctx.lineTo(x + size, y + size);
          ctx.lineTo(x, y + size);
          ctx.closePath();
          ctx.fill();
          break;
        case '2角丸中図形':
          ctx.beginPath();
          ctx.moveTo(x, y + size / 2);
          ctx.arcTo(x, y, x + size / 2, y, size / 4);
          ctx.lineTo(x + size, y);
          ctx.arcTo(x + size, y, x + size, y + size / 2, size / 4);
          ctx.lineTo(x + size, y + size);
          ctx.lineTo(x, y + size);
          ctx.closePath();
          ctx.fill();
          ctx.clearRect(x + size / 4, y + size / 4, size / 2, size / 2);
          break;
        case 'グラデーション':
          const gradient = ctx.createLinearGradient(x, y, x + size, y + size);
          gradient.addColorStop(0, color);
          gradient.addColorStop(1, getRandomElement(colors));
          ctx.fillStyle = gradient;
          ctx.fillRect(x, y, size, size);
          break;
        case 'なめらか四角':
          ctx.beginPath();
          ctx.moveTo(x + size / 4, y);
          ctx.lineTo(x + 3 * size / 4, y);
          ctx.quadraticCurveTo(x + size, y, x + size, y + size / 4);
          ctx.lineTo(x + size, y + 3 * size / 4);
          ctx.quadraticCurveTo(x + size, y + size, x + 3 * size / 4, y + size);
          ctx.lineTo(x + size / 4, y + size);
          ctx.quadraticCurveTo(x, y + size, x, y + 3 * size / 4);
          ctx.lineTo(x, y + size / 4);
          ctx.quadraticCurveTo(x, y, x + size / 4, y);
          ctx.fill();
          break;
        case 'ひし形':
          ctx.save();
          ctx.translate(x + size / 2, y + size / 2);
          ctx.rotate(Math.PI / 4);
          ctx.fillRect(-size / 2, -size / 2, size, size);
          ctx.restore();
          break;
        case '円形':
          ctx.beginPath();
          ctx.arc(x + size / 2, y + size / 2, size / 2, 0, 2 * Math.PI);
          ctx.fill();
          break;
        case '回転区切り':
          ctx.save();
          ctx.translate(x + size / 2, y + size / 2);
          ctx.rotate(Math.random() * Math.PI * 2);
          for (let i = 0; i < 4; i++) {
            ctx.fillRect(-size / 4, -size / 4, size / 2, size / 2);
            ctx.rotate(Math.PI / 2);
          }
          ctx.restore();
          break;
        case 'パソコン回転':
          ctx.save();
          ctx.translate(x + size / 2, y + size / 2);
          ctx.rotate(Math.random() * Math.PI * 2);
          ctx.beginPath();
          ctx.moveTo(-size / 2, -size / 4);
          ctx.lineTo(size / 2, -size / 4);
          ctx.lineTo(size / 4, size / 4);
          ctx.lineTo(-size / 4, size / 4);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
          break;
        case '同心円':
          for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.arc(x + size / 2, y + size / 2, size / 2 - (i * size / 10), 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = (i % 2 === 0) ? getRandomElement(colors) : color;
          }
          break;
        case '三角形連なり':
          ctx.beginPath();
          ctx.moveTo(x, y + size);
          ctx.lineTo(x + size / 2, y);
          ctx.lineTo(x + size, y + size);
          ctx.closePath();
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(x + size / 4, y + size);
          ctx.lineTo(x + size / 2, y + size / 2);
          ctx.lineTo(x + 3 * size / 4, y + size);
          ctx.closePath();
          ctx.fill();
          break;
        case '六角形':
          ctx.beginPath();
          ctx.moveTo(x + size / 4, y);
          ctx.lineTo(x + 3 * size / 4, y);
          ctx.lineTo(x + size, y + size / 2);
          ctx.lineTo(x + 3 * size / 4, y + size);
          ctx.lineTo(x + size / 4, y + size);
          ctx.lineTo(x, y + size / 2);
          ctx.closePath();
          ctx.fill();
          break;
        case '星形':
          ctx.beginPath();
          for (let i = 0; i < 5; i++) {
            ctx.lineTo(
              x + size / 2 + size / 2 * Math.cos((18 + i * 72) * Math.PI / 180),
              y + size / 2 - size / 2 * Math.sin((18 + i * 72) * Math.PI / 180)
            );
            ctx.lineTo(
              x + size / 2 + size / 4 * Math.cos((54 + i * 72) * Math.PI / 180),
              y + size / 2 - size / 4 * Math.sin((54 + i * 72) * Math.PI / 180)
            );
          }
          ctx.closePath();
          ctx.fill();
          break;
        case 'ギザギザ':
          ctx.beginPath();
          ctx.moveTo(x, y);
          for (let i = 0; i < 5; i++) {
            ctx.lineTo(x + (i + 0.5) * size / 5, y + (i % 2 === 0 ? size / 2 : 0));
          }
          ctx.lineTo(x + size, y + size);
          ctx.lineTo(x, y + size);
          ctx.closePath();
          ctx.fill();
          break;
        case '螺旋':
          ctx.save();
          ctx.translate(x + size / 2, y + size / 2);
          ctx.beginPath();
          for (let i = 0; i < 720; i++) {
            const angle = 0.1 * i;
            const spiralX = (1 + angle) * Math.cos(angle);
            const spiralY = (1 + angle) * Math.sin(angle);
            ctx.lineTo(spiralX, spiralY);
          }
          ctx.stroke();
          ctx.restore();
          break;
        case '対角線模様':
          ctx.fillRect(x, y, size, size);
          ctx.clearRect(x, y, size, size / 2);
          ctx.clearRect(x + size / 2, y + size / 2, size / 2, size / 2);
          break;
      }

      ctx.fillStyle = 'black';
      ctx.font = '16px Arial';
      ctx.fillText(`${year}年`, x, y + size + 20);
    }

    function generateLogos() {
      const initialSegments = parseInt(initialSegmentsInput.value);
      const changeFrequency = parseInt(changeFrequencyInput.value);

      const startYear = 2024;
      const endYear = 2500;
      const intervals = 40;
      const years = Array.from({ length: intervals }, (_, i) => startYear + Math.floor((endYear - startYear) / intervals * i));

      const logoSize = 100;
      let x = 50;
      let y = 50;

      const initialShapes = Array.from({ length: initialSegments }, () => '4区切り');
      const remainingShapes = shapeTypes.filter(shape => shape !== '4区切り');

      years.forEach((year, index) => {
        const color = getRandomElement(colors);
        let type;
        if (index < initialSegments) {
          type = '4区切り';
        } else if (index % changeFrequency === 0) {
          type = getRandomElement(remainingShapes);
        } else {
          type = initialShapes[index % initialShapes.length];
        }
        drawLogo(ctx, x, y, logoSize, year, color, type);
        x += logoSize + 50;
        if (x + logoSize > canvas.width) {
          x = 50;
          y += logoSize + 50;
        }
      });
    }

    function downloadImage() {
      const link = document.createElement('a');
      link.download = 'windows_logo_evolution.png';
      link.href = canvas.toDataURL();
      link.click();
    }

    generateButton.addEventListener('click', generateLogos);
    downloadButton.addEventListener('click', downloadImage);
  </script>
</body>
</html>
